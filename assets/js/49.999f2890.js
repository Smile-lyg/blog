(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{728:function(a,t,s){"use strict";s.r(t);var e=s(3),n=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("p",[a._v("JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。"),s("br"),a._v("\n为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。")])]),s("div",{staticClass:"language-js{1,4, 6} line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("const m = new Map()\nconst o = { p: 'hello' }\n\nm.set(o, 'content')\n\nconsole.log(m.get(o)) // content\n\nconsole.log(m.has(o)) // true\nconsole.log(m.delete(o)) // true\nconsole.log(m.has(o)) // false\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br")])]),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"title"}),s("p",[a._v("如果对同一个键多次赋值，后面的值将覆盖前面的值。"),s("br"),a._v("\n如果读取一个未知的键，则返回 undefined。"),s("br")])]),s("p",[a._v("Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("p",[a._v("如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键。"),s("br"),a._v("\n比如 0 和-0 就是一个键，布尔值 true 和字符串 true 则是两个不同的键。另外，undefined 和 null 也是两个不同的键。虽然 NaN 不严格相等于自身，但 Map 将其视为同一个键。")])]),s("h2",{attrs:{id:"实例的属性和操作方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实例的属性和操作方法"}},[a._v("#")]),a._v(" 实例的属性和操作方法")]),a._v(" "),s("h2",{attrs:{id:"属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#属性"}},[a._v("#")]),a._v(" 属性")]),a._v(" "),s("h3",{attrs:{id:"size-属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#size-属性"}},[a._v("#")]),a._v(" size 属性")]),a._v(" "),s("p",[a._v("size 属性返回 Map 结构的成员总数。")]),a._v(" "),s("h3",{attrs:{id:"map-prototype-set-key-value"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map-prototype-set-key-value"}},[a._v("#")]),a._v(" Map.prototype.set(key, value)")]),a._v(" "),s("p",[a._v("set 方法设置键名 key 对应的键值为 value，然后返回整个 Map 结构。如果 key 已经有值，则键值会被更新，否则就新生成该键。")]),a._v(" "),s("h3",{attrs:{id:"map-prototype-get-key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map-prototype-get-key"}},[a._v("#")]),a._v(" Map.prototype.get(key)")]),a._v(" "),s("p",[a._v("get 方法读取 key 对应的键值，如果找不到 key，返回 undefined。")]),a._v(" "),s("h3",{attrs:{id:"map-prototype-has-key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map-prototype-has-key"}},[a._v("#")]),a._v(" Map.prototype.has(key)")]),a._v(" "),s("p",[a._v("has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。")]),a._v(" "),s("h3",{attrs:{id:"map-prototype-delete-key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map-prototype-delete-key"}},[a._v("#")]),a._v(" Map.prototype.delete(key)")]),a._v(" "),s("p",[a._v("delete 方法删除某个键，返回 true。如果删除失败，返回 false。")]),a._v(" "),s("h3",{attrs:{id:"map-prototype-clear"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#map-prototype-clear"}},[a._v("#")]),a._v(" Map.prototype.clear()")]),a._v(" "),s("p",[a._v("clear 方法清除所有成员，没有返回值。")]),a._v(" "),s("h2",{attrs:{id:"遍历方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遍历方法"}},[a._v("#")]),a._v(" 遍历方法")]),a._v(" "),s("p",[a._v("Map 结构原生提供三个遍历器生成函数和一个遍历方法。")]),a._v(" "),s("ul",[s("li",[a._v("Map.prototype.keys()：返回键名的遍历器。")]),a._v(" "),s("li",[a._v("Map.prototype.values()：返回键值的遍历器。")]),a._v(" "),s("li",[a._v("Map.prototype.entries()：返回所有成员的遍历器。")]),a._v(" "),s("li",[a._v("Map.prototype.forEach()：遍历 Map 的所有成员。")])]),a._v(" "),s("p",[a._v("需要特别注意的是，Map 的遍历顺序就是插入顺序。")]),a._v(" "),s("h2",{attrs:{id:"weakmap"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#weakmap"}},[a._v("#")]),a._v(" WeakMap")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/set-map#WeakMap",target:"_blank",rel:"noopener noreferrer"}},[a._v("WeakMap"),s("OutboundLink")],1)]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"title"}),s("p",[a._v("WeakMap 的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。\n"),s("br"),a._v("\n总之，WeakMap 的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap 结构有助于防止内存泄漏。")])]),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"title"}),s("p",[a._v("注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。")])]),s("p",[a._v("WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。\nWeakMap 与 Map 的区别有两点。")]),a._v(" "),s("ul",[s("li",[a._v("首先，WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名。")]),a._v(" "),s("li",[a._v("其次，WeakMap 的键名所指向的对象，不计入垃圾回收机制。")])]),a._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" wm1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("WeakMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" key "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" foo"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\nwm1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("set")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\nwm1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("h2",{attrs:{id:"语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[a._v("#")]),a._v(" 语法")]),a._v(" "),s("p",[a._v("WeakMap 与 Map 在 API 上的区别主要是两个，")]),a._v(" "),s("ul",[s("li",[a._v("没有遍历操作（即没有 keys()、values()和 entries()方法）")]),a._v(" "),s("li",[a._v("没有 size 属性.")])]),a._v(" "),s("p",[a._v("eakMap 只有四个方法可用：get()、set()、has()、delete()。")])])}),[],!1,null,null,null);t.default=n.exports}}]);